package io.github.sinri.keel.base.configuration;

import io.github.sinri.keel.base.json.JsonObjectConvertible;
import io.github.sinri.keel.base.json.JsonObjectReloadable;
import io.github.sinri.keel.base.logger.factory.StdoutLoggerFactory;
import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;


/**
 * 配置节点。
 * <p>
 * 配置节点是树形结构中的一个节点，可以包含子节点和值。
 *
 * @since 5.0.0
 */
public class ConfigElement implements JsonObjectConvertible, JsonObjectReloadable {
    /**
     * 配置节点的子节点，以子节点名称为键的一个 Map。
     */
    @NotNull
    private final Map<String, ConfigElement> children;
    /**
     * 配置节点的名称
     */
    @NotNull
    private String name;
    /**
     * 配置节点的值。
     * <p>
     * 如果 value 为 null，视为未配置。
     */
    @Nullable
    private String value;

    /**
     * 以给定的名称构建一个配置节点。
     *
     * @param name 配置节点的名称
     */
    public ConfigElement(@NotNull String name) {
        this.name = name;
        this.value = null;
        this.children = new ConcurrentHashMap<>();
    }

    /**
     * 复刻一个配置节点。
     * <p>
     * 使用浅拷贝，各字段均与原字段一致。
     *
     * @param another 被复刻的配置节点
     */
    public ConfigElement(@NotNull ConfigElement another) {
        this.name = another.name;
        this.children = another.children;
        this.value = another.value;
    }

    /**
     * 从一个 JSON 对象生成一个配置节点。
     * <p>
     * 给定的 JSON 对象需要有 name、value、children 三个字段；
     * children 应为一个 JSON 数组，其中每个元素为一个 JSON 对象，描述一个子节点。
     * <p>
     * 曾用名：fromJsonObject
     *
     * @param jsonObject JSON 对象描述的配置信息
     * @return 生成的配置节点
     * @throws IllegalArgumentException 给定的 JSON 对象格式不正确
     */
    @NotNull
    private static ConfigElement decodeJsonObject(@NotNull JsonObject jsonObject) {
        String name = jsonObject.getString("name");
        Objects.requireNonNull(name, "name should not be null");
        ConfigElement configElement = new ConfigElement(name);
        if (jsonObject.containsKey("value")) {
            Object v = jsonObject.getValue("value");
            configElement.value = (v == null ? null : v.toString());
        }
        JsonArray children = jsonObject.getJsonArray("children");
        children.forEach(child -> {
            if (child instanceof JsonObject) {
                configElement.addChild(decodeJsonObject((JsonObject) child));
            } else {
                throw new IllegalArgumentException("Child should be a JSON object");
            }
        });
        return configElement;
    }

    /**
     * 基于 Vert.x Config 提供的能力，获取配置并组装为配置节点对象。
     *
     * @param configRetrieverOptions Vert.x Config 配置
     * @return 异步返回的配置节点对象
     * @see <a href="https://vertx.io/docs/vertx-config/java/">Vert.x Config</a>
     */
    @NotNull
    public static Future<ConfigElement> retrieve(@NotNull Vertx vertx, @NotNull ConfigRetrieverOptions configRetrieverOptions) {
        ConfigRetriever configRetriever = ConfigRetriever.create(vertx, configRetrieverOptions);
        return ConfigRetriever.create(vertx, configRetrieverOptions).getConfig()
                              .compose(jsonObject -> Future.succeededFuture(decodeJsonObject(jsonObject)))
                              .andThen(ar -> configRetriever.close());
    }

    /**
     * 以给定的配置节点为根节点，执行深度优先搜索，对具有非空值的配置项构建清单，均以字典序编列。
     *
     * @param node 给定的配置节点
     * @param path 给定的配置节点在完整的配置树中的路径，自根节点到当前节点
     * @param out  通过遍历收集到的配置项将加入到这个 {@link ConfigProperty} 列表中
     */
    private static void dfsTransform(@NotNull ConfigElement node,
                                     @NotNull List<String> path,
                                     @NotNull List<ConfigProperty> out) {
        // 当前节点若有值，则输出一条属性
        if (node.value != null) {
            out.add(new ConfigProperty()
                    .setKeychain(path)
                    .setValue(node.value));
        }
        // 继续遍历子节点
        if (!node.children.isEmpty()) {
            List<String> keys = new ArrayList<>(node.children.keySet());
            Collections.sort(keys);
            for (String k : keys) {
                ConfigElement child = node.children.get(k);
                if (child != null) {
                    List<String> nextPath = new ArrayList<>(path);
                    nextPath.add(k);
                    dfsTransform(child, nextPath, out);
                }
            }
        }
    }

    /**
     * 通过解析给定的 JSON 对象，完全重载本配置节点。
     *
     * @param jsonObject the JSON object with which this class should be reloaded, generated by
     *                   {@link ConfigElement#toJsonObject()}.
     */
    @Override
    public void reloadData(@NotNull JsonObject jsonObject) {
        ConfigElement configElement = decodeJsonObject(jsonObject);
        this.name = configElement.name;
        this.children.clear();
        configElement.children.values().forEach(this::addChild);
        this.value = configElement.value;
    }

    @NotNull
    public String getName() {
        return name;
    }

    /**
     * 获取本配置节点的值。
     *
     * @return 本配置节点的值。
     */
    @Nullable
    public String getValueAsString() {
        return value;
    }

    /**
     * 获取一个给定名称的子配置节点；如果尚不存在，则新建之。
     *
     * @param childName 子配置节点的名称
     * @return 子配置节点
     */
    @NotNull
    public ConfigElement ensureChild(@NotNull String childName) {
        return this.children.computeIfAbsent(childName, x -> new ConfigElement(childName));
    }

    /**
     * 向当前配置节点新增一个子配置节点。
     * <p>
     * 如果对应名称的子配置节点已存在，则会直接覆盖之。
     *
     * @param child 子配置节点
     * @return 本配置节点
     */
    @NotNull
    public ConfigElement addChild(@NotNull ConfigElement child) {
        this.children.put(child.getName(), child);
        return this;
    }

    /**
     * 移除某个子配置节点。
     *
     * @param child 子配置节点
     * @return 本配置节点
     */
    @NotNull
    public ConfigElement removeChild(@NotNull ConfigElement child) {
        this.removeChild(child.getName());
        return this;
    }

    /**
     * 移除某个子配置节点。
     *
     * @param childName 子配置节点的名称
     * @return 本配置节点
     */
    @NotNull
    public ConfigElement removeChild(@NotNull String childName) {
        this.children.remove(childName);
        return this;
    }

    /**
     * 设置本配置节点的值
     *
     * @param value 配置节点的值
     * @return 本配置节点
     */
    @NotNull
    public ConfigElement setValue(@NotNull String value) {
        this.value = value;
        return this;
    }


    @NotNull
    public Map<String, ConfigElement> getChildren() {
        return children;
    }

    /**
     * 获取本配置节点的子配置节点
     *
     * @param childName 子配置节点的名称
     * @return 子配置节点
     */
    @Nullable
    public ConfigElement getChild(@NotNull String childName) {
        return children.get(childName);
    }

    /**
     *
     * Converts the current object into a JSON representation.
     *
     * @return a JsonObject that represents the current object, including its name,
     *         children, and value if present.
     */
    @Override
    @NotNull
    public JsonObject toJsonObject() {
        JsonArray childArray = new JsonArray();
        children.forEach((cName, c) -> childArray.add(c.toJsonObject()));
        var x = new JsonObject()
                .put("name", name)
                .put("children", childArray);
        if (value != null) {
            x.put("value", value);
        }
        return x;
    }

    @Override
    public @NotNull String toJsonExpression() {
        return toJsonObject().encode();
    }

    @Override
    public @NotNull String toFormattedJsonExpression() {
        return toJsonObject().encodePrettily();
    }

    /**
     * 以本节点为根节点，根据路径下钻到子配置节点。
     *
     * @param path 路径。如果为空，表示停留在这个配置节点本身。
     * @return 子配置节点；如果找不到，则返回空。
     */
    public @Nullable ConfigElement extract(@NotNull List<String> path) {
        if (path.isEmpty())
            return this;
        if (path.size() == 1)
            return this.children.get(path.get(0));
        ConfigElement configElement = this.children.get(path.get(0));
        if (configElement == null) {
            return null;
        }
        for (int i = 1; i < path.size(); i++) {
            configElement = configElement.getChild(path.get(i));
            if (configElement == null) {
                return null;
            }
        }
        return configElement;
    }

    /**
     * 以本节点为根节点，根据路径下钻到子配置节点。
     *
     * @param path 路径。如果为空，表示停留在这个配置节点本身。
     * @return 子配置节点；如果找不到，则返回空。
     */
    public @Nullable ConfigElement extract(@NotNull String... path) {
        List<String> list = Arrays.asList(path);
        return this.extract(list);
    }

    /**
     * 通过给定的 {@link Properties} ，更新本配置节点的数据。
     * <p>
     * 通过遍历 {@link Properties} 里的键值对，将键根据其中的 {@code .} 分割为路径进行配置节点生成。
     *
     * @param properties 给定的 {@link Properties} 实例
     * @return 本配置节点
     */
    @NotNull
    public ConfigElement loadProperties(@NotNull Properties properties) {
        properties.forEach((k, v) -> {
            String fullKey = k.toString();
            String[] keyArray = fullKey.split("\\.");
            if (keyArray.length > 0) {
                ConfigElement configElement = children.computeIfAbsent(
                        keyArray[0],
                        x -> new ConfigElement(keyArray[0]));
                if (keyArray.length == 1) {
                    configElement.setValue(v.toString());
                } else {
                    for (int i = 1; i < keyArray.length; i++) {
                        String key = keyArray[i];
                        configElement = configElement.ensureChild(key);
                        if (i == keyArray.length - 1) {
                            configElement.setValue(v.toString());
                        }
                    }
                }
            }
        });
        return this;
    }

    /**
     * 通过给定的 {@code .properties} 文件名称（路径），以 UTF-8 编码加载并更新本配置节点的数据。
     *
     * @param propertiesFileName {@code .properties} 文件名称（路径）
     * @return 本配置节点
     */
    @NotNull
    public ConfigElement loadPropertiesFile(@NotNull String propertiesFileName) throws IOException {
        return loadPropertiesFile(propertiesFileName, StandardCharsets.UTF_8);
    }

    /**
     * 通过给定的 {@code .properties} 文件名称（路径），以指定字符编码加载并更新本配置节点的数据。
     *
     * @param propertiesFileName {@code .properties} 文件名称（路径）
     * @param charset            字符编码
     * @return 本配置节点
     */
    @NotNull
    public ConfigElement loadPropertiesFile(@NotNull String propertiesFileName, @NotNull Charset charset)
            throws IOException {
        File file = new File(propertiesFileName);
        Properties properties = new Properties();
        try {
            // here, the file named as `propertiesFileName` should be put along with JAR
            properties.load(new FileReader(file, charset));
        } catch (IOException e) {
            StdoutLoggerFactory.getInstance().createLogger(getClass().getName())
                               .warning("Cannot read the file %s. Use the embedded one.".formatted(file.getAbsolutePath()));
            InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(propertiesFileName);
            if (resourceAsStream == null) {
                // if the embedded file is not found, throw an IOException
                throw new IOException("The embedding properties file is not found.");
            }
            properties.load(resourceAsStream);
        }

        return loadProperties(properties);
    }

    /**
     * 通过给定的 {@code .properties} 文件内容，加载并更新本配置节点的数据。
     *
     * @param content {@code .properties} 文件内容
     * @return 本配置节点
     */
    @NotNull
    public ConfigElement loadPropertiesFileContent(@NotNull String content) {
        Properties properties = new Properties();
        try {
            properties.load(new StringReader(content));
        } catch (IOException e) {
            throw new RuntimeException("Cannot load given properties content.", e);
        }
        return loadProperties(properties);
    }

    /**
     * 将本配置节点的各有效配置项转化为配置项列表。
     *
     * @return 配置项 {@link ConfigProperty} 列表
     */
    @NotNull
    public List<ConfigProperty> transformChildrenToPropertyList() {
        List<ConfigProperty> properties = new ArrayList<>();
        // 为了输出稳定，按字典序遍历同级子节点
        List<String> keys = new ArrayList<>(this.children.keySet());
        Collections.sort(keys);
        for (String key : keys) {
            ConfigElement child = this.children.get(key);
            if (child != null) {
                dfsTransform(child, new ArrayList<>(List.of(key)), properties);
            }
        }
        return properties;
    }

}
